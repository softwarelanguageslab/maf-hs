\documentclass[acmsmall]{acmart}

\usepackage{color}
\usepackage{cleveref}

%% Colors: 
\definecolor{light-gray}{gray}{0.80}


\newcommand{\highlight}[1]{\colorbox{light-gray}{$#1$}}


\title{Contract systems from first principles}

\begin{document}

\maketitle

\section{Introduction}



\section{Background}

\section{Simplifying Sequential Contracts}

\subsection{From CFCP to the untyped $\lambda$ calculus}

\begin{figure}
   \begin{align*}
   e &::= \lambda x . e \mid e~e \mid b \mid \mathit{mon}(\kappa, e) \mid \mathsf{if}~e~e~e \\
   \kappa &::= \mathit{flat}~e \mid \kappa_1 \mapsto \kappa_2 \\
   b &::= \mathit{bool} \mid \mathit{int}
   \end{align*}
   \caption{Syntax for CFCP}\label{figure:syntax:cfcp}
\end{figure}

CFCP~\citep{DBLP:conf/icfp/FindlerF02} is an extension to the untyped $\lambda$-calculus for 
expressing contracts and their monitoring constructs.
Its syntax is depicted in \cref{figure:syntax:cfcp}
The language consists of two contract types (flat and higher-order) $\kappa$ which are separate from the term language.
The term language $e$ then contains a \emph{monitoring construct} which relates the contract language to the term language and to a set of \emph{blame labels}.
Thus, the main purpose of the monitoring construct is to attach blame labels to the appropriate values in the program and to \emph{dispatch}Â on the type of contract to achieve \emph{flat} or \emph{higher-order} contract monitoring respectively.

The semantics of the monitoring constructs is typically expressed as a reduction to a term in the untyped $\lambda$-calculus and does not require terms or values outside of it. 
This typical reduction rule in CFCP for the contract monitoring construct is depicted below.


\begin{align*}
\mathit{mon}^{j, k}(\textit{flat}~e_1, e_2) \rightarrow \mathsf{if}~(e_1~e_2)~e_2~\mathsf{blame}~j \\
\mathit{mon}^{j, k}(\kappa_1 \mapsto \kappa_2, ~f) \rightarrow \lambda x . \mathit{mon}^{j,k}(\kappa_2, f (\mathit{mon}^{k, j}(\kappa_1, x)))
\end{align*}

The result of reducing a flat contract monitor is $e_2$ if the predicate embedded in the flat contract holds for $e_2$, and a blame error otherwise. 
Reducing a higher-order contract monitor results in a $\lambda$-expression so that it can be used as a monitored version of $f$. 
Its semantics is straightforward. 
First, it checks the domain-contract $\kappa_1$ on its argument, and then checks its range-contract $\kappa_2$ on the result of applying function $f$ to this value.
Swapping of blame labels for checking the domain contract is crucial for higher-order functions.
This is because the roles of supplier and user are swapped. 
Whereas originally, the user was responsible for the arguments of the function, the supplier is now responsible for providing arguments to the function passed as an argument.

It is important to realize that the contract language is separate from the term language such that the contract specification and monitoring construct is entirely static and not influenced by the dataflow of the program. 
This renders a transformation to the untyped $\lambda$-calculus trivial by recursively applying the reduction rules depicted above until a flat contract is reached and the program 
is free of monitoring constructs and contract specifications.

\subsection{Higher-order contract combinators}

The CFCP approach to contract specification is rather limiting. 
A developer cannot build abstractions around its contracts to easily implement 
and re-use more complex contracts.
Racket~\cite{} provides a contract system that addresses these needs.
It does so by including the contract language in the term language, therefore making 
all abstraction and programming facilities from the term language available for 
contract specification.
In Racket, this results in a library of \emph{contract combinators} that 
are implemented as ordinary functions taking contracts as input and producing 
contracts as output. For instance, an \texttt{or/c} contract takes a number 
of contracts as an input and returns a contract that is valid for values 
satisfying one or more input contracts.
To facilitate contract combinators, the syntax is adapted as depicted below (changes highlighted in grey). 

\begin{align*}
   e &::= \lambda x . e \mid e~e \mid b \mid \mathit{mon}(\highlight{e}, e) \mid \mathsf{if}~e~e~e \mid \highlight{\kappa} \\
   \kappa &::= \mathit{flat}~e \mid \kappa_1 \mapsto \kappa_2 \\
   b &::= \mathit{bool} \mid \mathit{int}
\end{align*}

Now that contracts are also values in the term language, and contracts in monitor constructs are no longer static, a transformation to the untyped $\lambda$-calculus becomes more involved.
This is because the contract monitor construct has to perform run-time dispatching on the contract value.
One solution is to represent contracts as functions which encode their own monitoring semantics and reify blame labels as values.
For example, a flat contract can be represented as the function $\lambda j.\lambda k.\lambda x . \mathsf{if}~(e_1~x)~x~blame j$, similar for higher-order contracts.

% TODO: show adapted semantics and reduction rules

\subsection{Towards Blame Assignment through Provenance Tracking}




\bibliographystyle{ACM-Reference-Format}
\bibliography{sources}




\end{document}
